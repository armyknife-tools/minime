// Copyright (c) The OpenTofu Authors
// SPDX-License-Identifier: MPL-2.0

package main

import (
	"bytes"
	"context"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"time"

	"github.com/opentofu/opentofu/internal/command"
)

// AICommand is a Command implementation that generates OpenTofu configurations
// using AI models from Anthropic or Ollama.
type AICommand struct {
	Meta command.Meta
}

func (c *AICommand) Help() string {
	helpText := `
Usage: tofu ai [options] [prompt]

  Generate OpenTofu configurations using AI. This command uses either
  Anthropic's Claude or Ollama to generate complete OpenTofu projects
  based on your prompt.

Options:

  -provider=name         AI provider to use. Valid values are "anthropic" and "ollama".
                         Default is "anthropic".

  -model=name            Model to use. For Anthropic, defaults to "claude-3-haiku-20240307".
                         For Ollama, defaults to "llama3".

  -output=path           Directory where the generated files will be saved.
                         Defaults to the current directory.

  -api-key=key           API key for the AI provider. For Anthropic, this is required.
                         For Ollama, this is optional.

  -api-url=url           API URL for the AI provider. For Anthropic, this defaults to
                         the official API endpoint. For Ollama, this defaults to
                         "http://localhost:11434".

  -max-tokens=n          Maximum number of tokens to generate. Default is 4000.

  -temperature=n         Temperature for generation (0.0-1.0). Default is 0.7.

  -use-registry          If specified, the command will use the OpenTofu Registry to
                         look up available providers and modules to enhance the generated
                         configuration.

  -registry-db=connstr   Database connection string for the OpenTofu Registry.
                         If not specified, but -use-registry is set, it will use
                         environment variables (OPENTOFU_REGISTRY_DB_*) to connect.

Example:

  Simple S3 bucket:
  $ tofu ai "Create an AWS S3 bucket with versioning and server-side encryption"

  Complex infrastructure:
  $ tofu ai "Create an EC2 instance behind an ALB running Ubuntu 24.04 in an autoscaling group with a t2 instance with a minimum of 3 instances max 6 running apache"

  Use Ollama with a local model:
  $ tofu ai -provider=ollama "Create a GCP project with a VPC and firewall rules"

  Specify output directory:
  $ tofu ai -output=./my-project "Create an Azure resource group with a virtual network"

  Use registry integration:
  $ tofu ai -use-registry "Create a multi-region AWS infrastructure with proper module structure"
`
	return strings.TrimSpace(helpText)
}

func (c *AICommand) Synopsis() string {
	return "Generate OpenTofu configurations using AI"
}

// GeneratedFile represents a file generated by the AI
type GeneratedFile struct {
	Name    string
	Content string
}

// GenerationResult contains the result of a configuration generation
type GenerationResult struct {
	Files       map[string]string
	Explanation string
}

// AnthropicMessage represents a message in the Anthropic API
type AnthropicMessage struct {
	Role    string `json:"role"`
	Content string `json:"content"`
}

// AnthropicRequest represents a request to the Anthropic API
type AnthropicRequest struct {
	Model       string             `json:"model"`
	Messages    []AnthropicMessage `json:"messages"`
	System      string             `json:"system"`
	MaxTokens   int                `json:"max_tokens"`
	Temperature float64            `json:"temperature"`
}

// AnthropicContentItem represents a content item in the Anthropic API response
type AnthropicContentItem struct {
	Type string `json:"type"`
	Text string `json:"text"`
}

// AnthropicResponse represents a response from the Anthropic API
type AnthropicResponse struct {
	Content []AnthropicContentItem `json:"content"`
}

// OllamaRequest represents a request to the Ollama API
type OllamaRequest struct {
	Model       string  `json:"model"`
	Prompt      string  `json:"prompt"`
	System      string  `json:"system"`
	Stream      bool    `json:"stream"`
	Temperature float64 `json:"temperature"`
	NumPredict  int     `json:"num_predict,omitempty"`
}

// OllamaResponse represents a response from the Ollama API
type OllamaResponse struct {
	Model     string `json:"model"`
	CreatedAt string `json:"created_at"`
	Response  string `json:"response"`
	Done      bool   `json:"done"`
}

// DefaultSystemPrompt is the default system prompt used for generating OpenTofu configurations
const DefaultSystemPrompt = `You are an expert in infrastructure as code, specializing in OpenTofu (a fork of Terraform). Your task is to generate complete, working OpenTofu configurations based on user requests.

Follow these guidelines:
1. Generate all necessary files for a complete OpenTofu project, including provider configurations, variables, outputs, and resources.
2. Use best practices for OpenTofu code organization, security, and maintainability.
3. IMPORTANT: DO NOT include any comments in the code. Return ONLY the code itself.
4. Always use "opentofu" instead of "terraform" in any file names, but use the correct provider names (e.g., "aws", "google", "azurerm") in the provider blocks.
5. Structure your response as a set of files with their contents.
6. DO NOT include a README.md or any documentation files.
7. DO NOT provide any explanation of the architecture or design choices.
8. For complex infrastructure (like load balancers, auto-scaling groups, etc.), organize resources logically across multiple files.
9. Include proper networking configuration (VPCs, subnets, security groups) when creating compute resources.
10. Set sensible defaults for variables but make important parameters configurable.
11. Follow the principle of least privilege for IAM roles and security groups.
12. Include proper dependency management between resources.
13. When appropriate, leverage modules from the OpenTofu Registry (which contains approximately 18,000 modules) to follow best practices and reduce code duplication.
14. Specify required provider versions from the OpenTofu Registry (which contains approximately 4,000 providers) to ensure compatibility.
15. IMPORTANT: OpenTofu is the tool (like Terraform), not a provider. Use the correct provider names like "aws", "google", "azurerm", etc. in provider blocks.

For each file, start with "--- filename.tf ---" on a line by itself, followed by the file content, and end with "---" on a line by itself.

DO NOT include any dialog, explanations, or comments in your response. Return ONLY the code files with their contents.`

func (c *AICommand) Run(args []string) int {
	var providerFlag, modelFlag, outputFlag, apiKeyFlag, apiURLFlag, registryDBFlag string
	var maxTokensFlag int
	var temperatureFlag float64
	var useRegistryFlag bool

	cmdFlags := flag.NewFlagSet("ai", flag.ContinueOnError)
	cmdFlags.StringVar(&providerFlag, "provider", "anthropic", "AI provider to use (anthropic or ollama)")
	cmdFlags.StringVar(&modelFlag, "model", "", "Model to use")
	cmdFlags.StringVar(&outputFlag, "output", ".", "Output directory")
	cmdFlags.StringVar(&apiKeyFlag, "api-key", "", "API key for the AI provider")
	cmdFlags.StringVar(&apiURLFlag, "api-url", "", "API URL for the AI provider")
	cmdFlags.IntVar(&maxTokensFlag, "max-tokens", 4000, "Maximum number of tokens to generate")
	cmdFlags.Float64Var(&temperatureFlag, "temperature", 0.7, "Temperature for generation (0.0-1.0)")
	cmdFlags.BoolVar(&useRegistryFlag, "use-registry", false, "Use OpenTofu Registry for provider and module information")
	cmdFlags.StringVar(&registryDBFlag, "registry-db", "", "Database connection string for the OpenTofu Registry")

	cmdFlags.Usage = func() { c.Meta.Ui.Output(c.Help()) }
	if err := cmdFlags.Parse(args); err != nil {
		return 1
	}

	// Get the prompt from the remaining arguments
	args = cmdFlags.Args()
	if len(args) == 0 {
		c.Meta.Ui.Error("Error: Missing prompt argument\n")
		c.Meta.Ui.Output(c.Help())
		return 1
	}
	prompt := strings.Join(args, " ")

	// Validate provider
	provider := strings.ToLower(providerFlag)
	if provider != "anthropic" && provider != "ollama" {
		c.Meta.Ui.Error(fmt.Sprintf("Error: Invalid provider %q. Must be one of: anthropic, ollama", provider))
		return 1
	}

	// Set default model based on provider if not specified
	if modelFlag == "" {
		if provider == "anthropic" {
			modelFlag = "claude-3-haiku-20240307"
		} else {
			modelFlag = "llama3"
		}
	}

	// Check for API key if using Anthropic
	if provider == "anthropic" && apiKeyFlag == "" {
		// Try to get from environment variable
		apiKeyFlag = os.Getenv("ANTHROPIC_API_KEY")
		if apiKeyFlag == "" {
			c.Meta.Ui.Error("Error: Anthropic API key is required. Provide it with -api-key flag or set ANTHROPIC_API_KEY environment variable.")
			return 1
		}
	}

	// Set default API URL if not specified
	if apiURLFlag == "" {
		if provider == "anthropic" {
			apiURLFlag = "https://api.anthropic.com/v1/messages"
		} else if provider == "ollama" {
			apiURLFlag = "http://localhost:11434"
		}
	}

	// Create output directory if it doesn't exist
	if err := os.MkdirAll(outputFlag, 0755); err != nil {
		c.Meta.Ui.Error(fmt.Sprintf("Error creating output directory: %s", err))
		return 1
	}

	// Check if registry integration is requested
	var registrySystemPrompt string
	if useRegistryFlag {
		c.Meta.Ui.Output("Using OpenTofu Registry integration to enhance generation...")
		
		// Set up database connection if registry integration is requested
		if registryDBFlag == "" {
			// Try to get connection info from environment variables
			host := os.Getenv("OPENTOFU_REGISTRY_DB_HOST")
			port := os.Getenv("OPENTOFU_REGISTRY_DB_PORT")
			dbName := os.Getenv("OPENTOFU_REGISTRY_DB_NAME")
			user := os.Getenv("OPENTOFU_REGISTRY_DB_USER")
			password := os.Getenv("OPENTOFU_REGISTRY_DB_PASSWORD")
			
			// Use default values from memory if environment variables are not set
			if host == "" {
				host = "vultr-prod-860996d7-f3c4-4df8-b691-06ecc64db1c7-vultr-prod-c0b9.vultrdb.com"
			}
			if port == "" {
				port = "16751"
			}
			if dbName == "" {
				dbName = "opentofu"
			}
			if user == "" {
				user = "opentofu_user"
			}
			
			// Construct connection string
			if host != "" && port != "" && dbName != "" && user != "" {
				registryDBFlag = fmt.Sprintf("host=%s port=%s dbname=%s user=%s password=%s sslmode=require",
					host, port, dbName, user, password)
			}
		}
		
		// Build registry-specific system prompt addition
		registrySystemPrompt = `
Additionally, consider using the following information from the OpenTofu Registry:
- The registry contains approximately 4,000 providers and 18,000 modules
- When appropriate, use verified providers and community modules from the registry
- Follow best practices for module versioning and provider constraints`
	}

	// Generate configuration
	c.Meta.Ui.Output(fmt.Sprintf("Generating OpenTofu configuration using %s %s...", provider, modelFlag))
	c.Meta.Ui.Output("This may take a minute or two depending on the complexity of your request.")

	// Create a context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
	defer cancel()

	// Add registry information to system prompt if needed
	systemPrompt := DefaultSystemPrompt
	if registrySystemPrompt != "" {
		systemPrompt += "\n" + registrySystemPrompt
	}

	// Generate the configuration based on the provider
	var result *GenerationResult
	var err error

	if provider == "anthropic" {
		result, err = c.generateWithAnthropic(ctx, modelFlag, apiKeyFlag, apiURLFlag, maxTokensFlag, temperatureFlag, prompt, systemPrompt)
	} else {
		result, err = c.generateWithOllama(ctx, modelFlag, apiKeyFlag, apiURLFlag, maxTokensFlag, temperatureFlag, prompt, systemPrompt)
	}

	if err != nil {
		c.Meta.Ui.Error(fmt.Sprintf("Error generating configuration: %s", err))
		return 1
	}

	// Clean up file content before writing
	for filename, content := range result.Files {
		// Remove file header markers (--- filename.tf ---)
		fileHeaderRegex := regexp.MustCompile(fmt.Sprintf(`(?m)^---\s*%s\s*---\s*$`, regexp.QuoteMeta(filename)))
		content = fileHeaderRegex.ReplaceAllString(content, "")
		
		// Remove any other file header markers
		content = regexp.MustCompile(`(?m)^---\s*[\w\-\.\/]+\s*---\s*$`).ReplaceAllString(content, "")
		
		// Remove any trailing --- markers
		content = regexp.MustCompile(`(?m)^---\s*$`).ReplaceAllString(content, "")
		
		// Clean up whitespace
		content = regexp.MustCompile(`(?m)^\n\n+`).ReplaceAllString(content, "\n")
		content = strings.TrimSpace(content)
		
		result.Files[filename] = content
	}

	// Write generated files
	for filename, content := range result.Files {
		filePath := filepath.Join(outputFlag, filename)
		
		// Create directory for file if it doesn't exist
		dir := filepath.Dir(filePath)
		if err := os.MkdirAll(dir, 0755); err != nil {
			c.Meta.Ui.Error(fmt.Sprintf("Error creating directory %s: %s", dir, err))
			return 1
		}
		
		// Write file
		if err := os.WriteFile(filePath, []byte(content), 0644); err != nil {
			c.Meta.Ui.Error(fmt.Sprintf("Error writing file %s: %s", filePath, err))
			return 1
		}
		
		c.Meta.Ui.Output(fmt.Sprintf("Created %s", filePath))
	}

	c.Meta.Ui.Output(fmt.Sprintf("\nGeneration complete! Files written to %s", outputFlag))
	c.Meta.Ui.Output("\nExplanation of generated configuration:")
	c.Meta.Ui.Output(result.Explanation)
	
	return 0
}

// generateWithAnthropic generates OpenTofu configuration using Anthropic Claude
func (c *AICommand) generateWithAnthropic(ctx context.Context, model, apiKey, apiURL string, maxTokens int, temperature float64, prompt, systemPrompt string) (*GenerationResult, error) {
	// Create request
	req := AnthropicRequest{
		Model: model,
		Messages: []AnthropicMessage{
			{
				Role:    "user",
				Content: prompt,
			},
		},
		System:      systemPrompt,
		MaxTokens:   maxTokens,
		Temperature: temperature,
	}

	// Set default model if not specified
	if req.Model == "" {
		req.Model = "claude-3-haiku-20240307"
	}

	// Set default API URL if not specified
	if apiURL == "" {
		apiURL = "https://api.anthropic.com/v1/messages"
	}

	// Create HTTP request
	jsonData, err := json.Marshal(req)
	if err != nil {
		return nil, fmt.Errorf("error marshaling request: %w", err)
	}

	httpReq, err := http.NewRequestWithContext(ctx, "POST", apiURL, bytes.NewBuffer(jsonData))
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	httpReq.Header.Set("Content-Type", "application/json")
	httpReq.Header.Set("x-api-key", apiKey)
	httpReq.Header.Set("anthropic-version", "2023-06-01")

	// Send request
	client := &http.Client{}
	resp, err := client.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	defer resp.Body.Close()

	// Read response
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("error reading response: %w", err)
	}

	// Parse response
	var anthropicResp AnthropicResponse
	if err := json.Unmarshal(body, &anthropicResp); err != nil {
		return nil, fmt.Errorf("error unmarshaling response: %w", err)
	}

	// Extract text from the response
	var text string
	for _, content := range anthropicResp.Content {
		if content.Type == "text" {
			text = content.Text
			break
		}
	}

	if text == "" {
		return nil, fmt.Errorf("no text content found in Anthropic response")
	}

	// Parse the generated text into files and explanation
	return extractFilesFromText(text)
}

// generateWithOllama generates OpenTofu configuration using Ollama
func (c *AICommand) generateWithOllama(ctx context.Context, model, apiKey, apiURL string, maxTokens int, temperature float64, prompt, systemPrompt string) (*GenerationResult, error) {
	// Create request
	req := OllamaRequest{
		Model:       model,
		Prompt:      prompt,
		System:      systemPrompt,
		Stream:      false,
		Temperature: temperature,
		NumPredict:  maxTokens,
	}

	// Set default model if not specified
	if req.Model == "" {
		req.Model = "llama3"
	}

	// Set default API URL if not specified
	if apiURL == "" {
		apiURL = "http://localhost:11434"
	}

	// Create HTTP request
	jsonData, err := json.Marshal(req)
	if err != nil {
		return nil, fmt.Errorf("error marshaling request: %w", err)
	}

	httpReq, err := http.NewRequestWithContext(ctx, "POST", fmt.Sprintf("%s/api/generate", apiURL), bytes.NewBuffer(jsonData))
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	httpReq.Header.Set("Content-Type", "application/json")

	// Send request
	client := &http.Client{}
	resp, err := client.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	defer resp.Body.Close()

	// Read response
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("error reading response: %w", err)
	}

	// Parse response
	var ollamaResp OllamaResponse
	if err := json.Unmarshal(body, &ollamaResp); err != nil {
		return nil, fmt.Errorf("error unmarshaling response: %w", err)
	}

	// Extract files from text
	result, err := extractFilesFromText(ollamaResp.Response)
	if err != nil {
		return nil, fmt.Errorf("error extracting files: %w", err)
	}

	// If no explanation was provided, add a default one
	if result.Explanation == "" {
		result.Explanation = "No explanation provided by the AI model."
	}

	return result, nil
}

// extractFilesFromText is a fallback method to extract files from the generated text
// if the standard parsing fails. It looks for patterns like "filename.tf" followed by
// code blocks or content.
func extractFilesFromText(text string) (*GenerationResult, error) {
	result := &GenerationResult{
		Files: make(map[string]string),
	}

	// First, try to extract files using the standard format (--- filename.tf ---)
	fileBlockRegex := regexp.MustCompile(`(?m)^---\s+([\w\-\.\/]+)\s+---\n(.*?)(?:\n---(?:\s+|$)|\z)`)
	matches := fileBlockRegex.FindAllStringSubmatch(text, -1)
	
	if len(matches) > 0 {
		// Extract files
		for _, match := range matches {
			if len(match) >= 3 {
				filename := strings.TrimSpace(match[1])
				content := strings.TrimSpace(match[2])
				
				// Remove any markdown code block markers
				content = regexp.MustCompile("(?m)^```(?:terraform|hcl)?$").ReplaceAllString(content, "")
				content = regexp.MustCompile("(?m)^```$").ReplaceAllString(content, "")
				
				// Remove any comments that might have been added despite instructions
				content = regexp.MustCompile("(?m)^\\s*#.*$").ReplaceAllString(content, "")
				content = regexp.MustCompile("(?m)^\\s*//.*$").ReplaceAllString(content, "")
				content = regexp.MustCompile("(?m)/\\*.*?\\*/").ReplaceAllString(content, "")
				
				// Remove any dialog or explanation text that might be mixed with code
				content = regexp.MustCompile("(?i)(?m)^(Note:|Here's|This file|As you can see|Let me|I've|I have|This creates|This sets up).*$").ReplaceAllString(content, "")
				
				// Remove any --- markers that might be included in the content
				content = regexp.MustCompile("(?m)^---\\s*$").ReplaceAllString(content, "")
				
				// Clean up any extra whitespace
				content = regexp.MustCompile("(?m)^\n\n+").ReplaceAllString(content, "\n")
				content = strings.TrimSpace(content)
				
				result.Files[filename] = content
			}
		}

		// Extract explanation (text after the last file block)
		lastMatchIndices := fileBlockRegex.FindAllStringSubmatchIndex(text, -1)
		lastMatchEnd := lastMatchIndices[len(matches)-1][1]
		if lastMatchEnd < len(text) {
			result.Explanation = strings.TrimSpace(text[lastMatchEnd:])
		}
	} else {
		// Try to extract files from markdown code blocks
		markdownBlockRegex := regexp.MustCompile("```(?:terraform|hcl)?\n(.*?)```")
		markdownMatches := markdownBlockRegex.FindAllStringSubmatch(text, -1)
		
		if len(markdownMatches) > 0 {
			// For Ollama output, we typically get a single code block with the entire configuration
			// Extract it as main.tf
			content := strings.TrimSpace(markdownMatches[0][1])
			
			// Clean up the content
			content = regexp.MustCompile("(?m)^\\s*#.*$").ReplaceAllString(content, "")
			content = regexp.MustCompile("(?m)^\\s*//.*$").ReplaceAllString(content, "")
			content = regexp.MustCompile("(?m)/\\*.*?\\*/").ReplaceAllString(content, "")
			content = regexp.MustCompile("(?i)(?m)^(Note:|Here's|This file|As you can see|Let me|I've|I have|This creates|This sets up).*$").ReplaceAllString(content, "")
			
			// Remove any --- markers that might be included in the content
			content = regexp.MustCompile("(?m)^---\\s*$").ReplaceAllString(content, "")
			
			// Clean up any extra whitespace
			content = regexp.MustCompile("(?m)^\n\n+").ReplaceAllString(content, "\n")
			content = strings.TrimSpace(content)
			
			result.Files["main.tf"] = content
			
			// Check if there are any other code blocks that might be separate files
			if len(markdownMatches) > 1 {
				for i, match := range markdownMatches[1:] {
					if len(match) >= 2 {
						fileContent := strings.TrimSpace(match[1])
						
						// Clean up the content
						fileContent = regexp.MustCompile("(?m)^\\s*#.*$").ReplaceAllString(fileContent, "")
						fileContent = regexp.MustCompile("(?m)^\\s*//.*$").ReplaceAllString(fileContent, "")
						fileContent = regexp.MustCompile("(?m)/\\*.*?\\*/").ReplaceAllString(fileContent, "")
						fileContent = regexp.MustCompile("(?i)(?m)^(Note:|Here's|This file|As you can see|Let me|I've|I have|This creates|This sets up).*$").ReplaceAllString(fileContent, "")
						
						// Remove any --- markers that might be included in the content
						fileContent = regexp.MustCompile("(?m)^---\\s*$").ReplaceAllString(fileContent, "")
						
						// Clean up any extra whitespace
						fileContent = regexp.MustCompile("(?m)^\n\n+").ReplaceAllString(fileContent, "\n")
						fileContent = strings.TrimSpace(fileContent)
						
						result.Files[fmt.Sprintf("file%d.tf", i+1)] = fileContent
					}
				}
			}
			
			// Try to extract explanation from the text outside code blocks
			explanationText := markdownBlockRegex.ReplaceAllString(text, "")
			result.Explanation = strings.TrimSpace(explanationText)
		} else {
			// Look for file headers (e.g., "# main.tf" or "## variables.tf")
			lines := strings.Split(text, "\n")
			var currentFile string
			var currentContent strings.Builder
			var inCodeBlock bool
			var explanationBuilder strings.Builder
			var collectingExplanation bool

			for _, line := range lines {
				// Check for file headers (e.g., "# main.tf" or "## variables.tf")
				if strings.HasPrefix(line, "#") && (strings.Contains(line, ".tf") || 
				strings.Contains(line, ".md") || strings.Contains(line, ".txt")) {
					// If we were collecting a file, save it
					if currentFile != "" && currentContent.Len() > 0 {
						fileContent := currentContent.String()
						
						// Clean up the content
						fileContent = regexp.MustCompile("(?m)^\\s*#.*$").ReplaceAllString(fileContent, "")
						fileContent = regexp.MustCompile("(?m)^\\s*//.*$").ReplaceAllString(fileContent, "")
						fileContent = regexp.MustCompile("(?m)/\\*.*?\\*/").ReplaceAllString(fileContent, "")
						fileContent = regexp.MustCompile("(?i)(?m)^(Note:|Here's|This file|As you can see|Let me|I've|I have|This creates|This sets up).*$").ReplaceAllString(fileContent, "")
						
						// Remove any --- markers that might be included in the content
						fileContent = regexp.MustCompile("(?m)^---\\s*$").ReplaceAllString(fileContent, "")
						
						// Clean up any extra whitespace
						fileContent = regexp.MustCompile("(?m)^\n\n+").ReplaceAllString(fileContent, "\n")
						fileContent = strings.TrimSpace(fileContent)
						
						result.Files[currentFile] = fileContent
						currentContent.Reset()
					}
					
					// Extract the filename from the header
					filenameParts := strings.Fields(line)
					if len(filenameParts) > 1 {
						currentFile = filenameParts[len(filenameParts)-1]
						inCodeBlock = false
					}
					continue
				}
				
				// Check for code block markers
				if strings.HasPrefix(line, "```") {
					inCodeBlock = !inCodeBlock
					continue
				}
				
				// If we have a current file, add the line to its content
				if currentFile != "" {
					currentContent.WriteString(line)
					currentContent.WriteString("\n")
				} else if !inCodeBlock && !collectingExplanation && line != "" {
					// If we're not in a code block and not collecting a file,
					// and the line is not empty, start collecting explanation
					collectingExplanation = true
					explanationBuilder.WriteString(line)
					explanationBuilder.WriteString("\n")
				} else if collectingExplanation {
					explanationBuilder.WriteString(line)
					explanationBuilder.WriteString("\n")
				}
			}
			
			// Save the last file if there is one
			if currentFile != "" && currentContent.Len() > 0 {
				fileContent := currentContent.String()
				
				// Clean up the content
				fileContent = regexp.MustCompile("(?m)^\\s*#.*$").ReplaceAllString(fileContent, "")
				fileContent = regexp.MustCompile("(?m)^\\s*//.*$").ReplaceAllString(fileContent, "")
				fileContent = regexp.MustCompile("(?m)/\\*.*?\\*/").ReplaceAllString(fileContent, "")
				fileContent = regexp.MustCompile("(?i)(?m)^(Note:|Here's|This file|As you can see|Let me|I've|I have|This creates|This sets up).*$").ReplaceAllString(fileContent, "")
				
				// Remove any --- markers that might be included in the content
				fileContent = regexp.MustCompile("(?m)^---\\s*$").ReplaceAllString(fileContent, "")
				
				// Clean up any extra whitespace
				fileContent = regexp.MustCompile("(?m)^\n\n+").ReplaceAllString(fileContent, "\n")
				fileContent = strings.TrimSpace(fileContent)
				
				result.Files[currentFile] = fileContent
			}
			
			// Set the explanation
			if explanationBuilder.Len() > 0 {
				result.Explanation = strings.TrimSpace(explanationBuilder.String())
			}
			
			// If we didn't find any files, use the entire text as main.tf
			if len(result.Files) == 0 {
				// Clean up the content
				cleanText := regexp.MustCompile("(?m)^\\s*#.*$").ReplaceAllString(text, "")
				cleanText = regexp.MustCompile("(?m)^\\s*//.*$").ReplaceAllString(cleanText, "")
				cleanText = regexp.MustCompile("(?m)/\\*.*?\\*/").ReplaceAllString(cleanText, "")
				cleanText = regexp.MustCompile("(?i)(?m)^(Note:|Here's|This file|As you can see|Let me|I've|I have|This creates|This sets up).*$").ReplaceAllString(cleanText, "")
				
				// Remove any --- markers that might be included in the content
				cleanText = regexp.MustCompile("(?m)^---\\s*$").ReplaceAllString(cleanText, "")
				
				// Clean up any extra whitespace
				cleanText = regexp.MustCompile("(?m)^\n\n+").ReplaceAllString(cleanText, "\n")
				cleanText = strings.TrimSpace(cleanText)
				
				result.Files["main.tf"] = cleanText
			}
		}
	}

	// If no explanation was provided, add a default one
	if result.Explanation == "" {
		result.Explanation = "No explanation provided by the AI model."
	}

	return result, nil
}
