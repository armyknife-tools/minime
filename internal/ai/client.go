// Copyright (c) The OpenTofu Authors
// SPDX-License-Identifier: MPL-2.0

package ai

import (
	"context"
	"fmt"
	"regexp"
	"strings"
)

// GeneratedFile represents a file generated by the AI
type GeneratedFile struct {
	Name    string
	Content string
}

// GenerationResult contains the result of a configuration generation
type GenerationResult struct {
	Files       map[string]string
	Explanation string
}

// Client is the interface for AI clients
type Client interface {
	Generate(ctx context.Context, prompt, systemPrompt string) (*GenerationResult, error)
}

// ExtractFilesFromText is a helper function to extract files from the generated text
// if the standard parsing fails. It looks for patterns like "filename.tf" followed by
// code blocks or content.
func ExtractFilesFromText(text string) (*GenerationResult, error) {
	result := &GenerationResult{
		Files: make(map[string]string),
	}

	// First, try to extract files using the standard format (--- filename.tf ---)
	fileBlockRegex := regexp.MustCompile(`(?m)^---\s+([\w\-\.\/]+)\s+---\n(.*?)(?:\n---(?:\s+|$)|\z)`)
	matches := fileBlockRegex.FindAllStringSubmatch(text, -1)
	
	if len(matches) > 0 {
		// Extract files
		for _, match := range matches {
			if len(match) >= 3 {
				filename := strings.TrimSpace(match[1])
				content := strings.TrimSpace(match[2])
				result.Files[filename] = content
			}
		}

		// Extract explanation (text after the last file block)
		lastMatchIndices := fileBlockRegex.FindAllStringSubmatchIndex(text, -1)
		lastMatchEnd := lastMatchIndices[len(matches)-1][1]
		if lastMatchEnd < len(text) {
			result.Explanation = strings.TrimSpace(text[lastMatchEnd:])
		}
	} else {
		// Try to extract files from markdown code blocks
		markdownBlockRegex := regexp.MustCompile("```(?:terraform|hcl)?\n(.*?)```")
		markdownMatches := markdownBlockRegex.FindAllStringSubmatch(text, -1)
		
		if len(markdownMatches) > 0 {
			// For Ollama output, we typically get a single code block with the entire configuration
			// Extract it as main.tf
			content := strings.TrimSpace(markdownMatches[0][1])
			result.Files["main.tf"] = content
			
			// Check if there are any other code blocks that might be separate files
			if len(markdownMatches) > 1 {
				for i, match := range markdownMatches[1:] {
					if len(match) >= 2 {
						result.Files[fmt.Sprintf("file%d.tf", i+1)] = strings.TrimSpace(match[1])
					}
				}
			}
			
			// Try to extract explanation from the text outside code blocks
			explanationText := markdownBlockRegex.ReplaceAllString(text, "")
			result.Explanation = strings.TrimSpace(explanationText)
		} else {
			// Look for file headers (e.g., "# main.tf" or "## variables.tf")
			lines := strings.Split(text, "\n")
			var currentFile string
			var currentContent strings.Builder
			var inCodeBlock bool
			var explanationBuilder strings.Builder
			var collectingExplanation bool

			for _, line := range lines {
				// Check for file headers (e.g., "# main.tf" or "## variables.tf")
				if strings.HasPrefix(line, "#") && (strings.Contains(line, ".tf") || 
				strings.Contains(line, ".md") || strings.Contains(line, ".txt")) {
					// If we were collecting a file, save it
					if currentFile != "" && currentContent.Len() > 0 {
						result.Files[currentFile] = currentContent.String()
						currentContent.Reset()
					}
					
					// Extract the filename from the header
					filenameParts := strings.Fields(line)
					if len(filenameParts) > 1 {
						currentFile = filenameParts[len(filenameParts)-1]
						inCodeBlock = false
					}
					continue
				}
				
				// Check for code block markers
				if strings.HasPrefix(line, "```") {
					inCodeBlock = !inCodeBlock
					continue
				}
				
				// If we have a current file, add the line to its content
				if currentFile != "" {
					currentContent.WriteString(line)
					currentContent.WriteString("\n")
				} else if !inCodeBlock && !collectingExplanation && line != "" {
					// If we're not in a code block and not collecting a file,
					// and the line is not empty, start collecting explanation
					collectingExplanation = true
					explanationBuilder.WriteString(line)
					explanationBuilder.WriteString("\n")
				} else if collectingExplanation {
					explanationBuilder.WriteString(line)
					explanationBuilder.WriteString("\n")
				}
			}
			
			// Save the last file if there is one
			if currentFile != "" && currentContent.Len() > 0 {
				result.Files[currentFile] = currentContent.String()
			}
			
			// Set the explanation
			if explanationBuilder.Len() > 0 {
				result.Explanation = strings.TrimSpace(explanationBuilder.String())
			}
			
			// If we didn't find any files, use the entire text as main.tf
			if len(result.Files) == 0 {
				result.Files["main.tf"] = text
			}
		}
	}

	// If no explanation was provided, add a default one
	if result.Explanation == "" {
		result.Explanation = "No explanation provided by the AI model."
	}

	return result, nil
}
